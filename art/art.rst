Temat: Jak działa super?
Jest jedna funkcjonalność Pythona, której wszyscy używają bardzo szczątkowo, gdyż panuje opinia iż nadużywanie jej może doprowadzić do nieokreślonego działania aplikacji. Tą funkcjonalnością jest wielodziedziczenie. Postaram się w kilku słowach pokazać jak działa "Method Resolution Order" w Pythonie (wybaczcie, nie znalazłem dobrego tłumaczenia tej nazwy). Postaram się wam pokazać jak można użyć "super", aby zamockować i przetestować przykładową klasę.
Zacznijmy jednak od teorii. W programowaniu panuje przekonanie, że wielodziedziczenie jest złe, gdyż może występować "the diamond problem", czyli sytuacja, w której klasa dziedziczy po dwóch klasach, a te dwie klasy dziedziczą po jednej i tej samej. Gdybyś my w takiej sytuacji (powiedzmy w C++) we wszystkich klasach zaimplementowali taką samą metodę, to język nie wiedziałby którą metodę wywołać najpierw.  W Pythonie ten problem nie występuje, dzięki MRO, który to jest implementacją algorytmu "C3 linearization"*. Wprowadzono go w wersji 2.3 (new style classes) oraz w Perl 5 i Parrot. Niestety nie są znane mi inne języki, które by implementowały ten algorytm.
Dodatkowym atutem Pythona jest fakt, iż wywołanie metody rodzica, jest jawne w metodzie potomka. Dzięki temu, można kod rodzica uruchomić nie tylko przed wywołaniem własnej metody, ale na przykład w środku. Daje nam to naprawdę duże pole do manewru.
.. image:: picture.png
Weźmy pod uwagę tę specyficzną sytuację (wyciągniętą z jednego mojego projektu). Jest to hierarchia dziedziczenia jednej klasy i jej rodziców. Liczby w nawiasach określają numer
OrdersListController dziedziczy po Controller. Tutaj jest jeszcze wszystko zrozumiałe. Jednak Controller dziedziczy już po 4 klasach (w kolejności):
 * Requestable
 * FanstaticController
 * FormskitController
 * FlashMessageController
Tutaj wprawdzie jest już zastosowane dziedziczenie po wielu klasach bazowych, jednak MRO w takiej sytuacji jeszcze nie pokazuje swoich możliwości. To co dzieje się głębiej już jest sednem użycia "C3 linearization". FlashMessageController jest 5. w kolejności, co kończy listę bezpośrednich rodziców klasy Controller. To, że BaseController ma numerek 6 wymaga już niestety trochę większego zastanowienia. Nie będę się nawet starał tłumaczyć czemu akurat tak to zostało obliczone (gdyż ten temat bardzo dobrze opisał na swojej prelekcji Raymond Hettinger, twórca implementacji MRO. Prelekcja nazywa się "Super considered super!"*).
Tym diagramem chciałem natomiast pokazać, iż w Pythonie nie występuje "the diamond problem". Jest jeszcze jedna bardzo ważna cecha tego algorytmu: dziecko nigdy nie wie która metoda zostanie wykonana, gdy użyjemy super(). Zwróćcie proszę uwagę na klasę FanstaticController (z numerkiem 3). Dziedziczy ona jedynie po klasie BaseController, a nic nie wie o klasie FormskitController (z numerkiem 4), która będzie wykonana zaraz po niej. Jest tak tylko dlatego, że klasa Controller dziedziczy po tych dwóch klasach.
Ta konkretna funkcjonalność daje nam bardzo ciekawą możliwość. Mieliście kiedyś problem o nazwie "jak zmockować funkcję super() ?". Czyli w testach chcecie wykonać kod z jednej klasy, ale nie chcecie wykonywać kod rodziców. Można to zrobić bardzo prosto: wybierzmy klasę do testów, w tym przypadku "OrdersListController". Tworzymy zatem klasę MockedOrderListController, która będzie dziedziczyłą po tych samych klasach co OrderListController. A następnie robimy pustą klasę OrdersListControllerEx, która dziedziczy po OrdersListController oraz MockedOrderListController (w tej kolejności). Dzięki czemu najpierw zostanie wykonana metoda z klasy OrdersListController, a potem MockedOrderListController. W samym MockedOrderListController po prostu nie wywołujemy metody super(), dzięki czemu nie zostanie wykonany żaden kod rodziców.

* https://en.wikipedia.org/wiki/C3_linearization
* https://www.youtube.com/watch?v=EiOglTERPEo
